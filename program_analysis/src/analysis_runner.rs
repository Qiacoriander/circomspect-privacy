use log::{debug, trace};
use std::path::PathBuf;
use std::collections::HashMap;

use parser::ParseResult;

use program_structure::{
    writers::{LogWriter, ReportWriter},
    template_data::TemplateInfo,
    function_data::FunctionInfo,
    file_definition::{FileLibrary, FileLocation, FileID},
    cfg::{Cfg, IntoCfg},
    constants::Curve,
    report::{ReportCollection, Report},
};

#[cfg(test)]
use program_structure::template_library::TemplateLibrary;

use crate::{
    analysis_context::{AnalysisContext, AnalysisError},
    get_analysis_passes, config,
    privacy_taint::LeakSeverity,
};

type CfgCache = HashMap<String, Cfg>;
type ReportCache = HashMap<String, ReportCollection>;

/// A type responsible for caching CFGs and running analysis passes over all
/// functions and templates.
#[derive(Default)]
pub struct AnalysisRunner {
    curve: Curve,
    leak_threshold: usize,
    min_leak_severity: LeakSeverity,
    libraries: Vec<PathBuf>,
    /// The corresponding file library including file includes.
    file_library: FileLibrary,
    /// Template ASTs generated by the parser.
    template_asts: TemplateInfo,
    /// Function ASTs generated by the parser.
    function_asts: FunctionInfo,
    /// Cached template CFGs generated on demand.
    template_cfgs: CfgCache,
    /// Cached function CFGs generated on demand.
    function_cfgs: CfgCache,
    /// Reports created during CFG generation.
    template_reports: ReportCache,
    /// Reports created during CFG generation.
    function_reports: ReportCache,
    /// Main component information (if the program has a main component)
    main_component: Option<MainComponentInfo>,
}

/// Information about the main component, including public inputs and the template name
#[derive(Clone, Debug)]
pub struct MainComponentInfo {
    /// The name of the main template
    pub template_name: String,
    /// Public input signal names declared in main component
    pub public_inputs: Vec<String>,
}

impl AnalysisRunner {
    pub fn new(curve: Curve) -> Self {
        AnalysisRunner {
            curve,
            leak_threshold: 8,                     // 默认值为 8
            min_leak_severity: LeakSeverity::High, // 默认 High
            ..Default::default()
        }
    }

    pub fn with_leak_threshold(mut self, threshold: usize) -> Self {
        self.leak_threshold = threshold;
        self
    }

    pub fn with_min_leak_severity(mut self, severity: LeakSeverity) -> Self {
        self.min_leak_severity = severity;
        self
    }

    pub fn with_libraries(mut self, libraries: &[PathBuf]) -> Self {
        self.libraries.extend_from_slice(libraries); // 将一个切片的所有元素追加到另一个集合中
        self
    }

    /// 指定了输入文件后，会在这一环节进行解析
    pub fn with_files(mut self, input_files: &[PathBuf]) -> (Self, ReportCollection) {
        let reports =
            match parser::parse_files(input_files, &self.libraries, &config::COMPILER_VERSION) {
                // 解析出来可以是完成的程序(有且只有一个main)，其余情况视作库(Library)
                ParseResult::Program(program, warnings) => {
                    // 提取 main component 信息
                    if let program_structure::ast::Expression::Call { id, .. } =
                        program.main_expression()
                    {
                        self.main_component = Some(MainComponentInfo {
                            template_name: id.clone(),
                            public_inputs: program.public_inputs.clone(),
                        });
                    }
                    self.template_asts = program.templates;
                    self.function_asts = program.functions;
                    self.file_library = program.file_library;
                    warnings
                }
                ParseResult::Library(library, warnings) => {
                    self.template_asts = library.templates;
                    self.function_asts = library.functions;
                    self.file_library = library.file_library;
                    warnings
                }
            };
        (self, reports)
    }

    /// Convenience method used to generate a runner for testing purposes.
    #[cfg(test)]
    pub fn with_src(mut self, file_contents: &[&str]) -> Self {
        use parser::parse_definition;

        let mut library_contents = HashMap::new();
        let mut file_library = FileLibrary::default();
        for (file_index, file_source) in file_contents.iter().enumerate() {
            let file_name = format!("file-{file_index}.circom");
            let file_id = file_library.add_file(file_name, file_source.to_string(), true);
            // 这里parse_definition会解析出Definition，其实就是AST
            library_contents.insert(file_id, vec![parse_definition(file_source).unwrap()]);
        }
        let template_library = TemplateLibrary::new(library_contents, file_library.clone());
        self.template_asts = template_library.templates;
        self.function_asts = template_library.functions;
        self.file_library = template_library.file_library;

        self
    }

    pub fn file_library(&self) -> &FileLibrary {
        &self.file_library
    }

    pub fn main_component(&self) -> Option<&MainComponentInfo> {
        self.main_component.as_ref()
    }

    pub fn template_names(&self, user_input_only: bool) -> Vec<String> {
        // Clone template names to avoid holding multiple references to `self`.
        self.template_asts
            .iter()
            .filter_map(|(name, ast)| {
                if !user_input_only || self.file_library.is_user_input(ast.get_file_id()) {
                    // 不在指定的库的set中，则就是用户输入文件
                    Some(name)
                } else {
                    None
                }
            })
            .cloned()
            .collect()
    }

    pub fn function_names(&self, user_input_only: bool) -> Vec<String> {
        // Clone function names to avoid holding multiple references to `self`.
        self.function_asts
            .iter()
            .filter_map(|(name, ast)| {
                if !user_input_only || self.file_library.is_user_input(ast.get_file_id()) {
                    Some(name)
                } else {
                    None
                }
            })
            .cloned()
            .collect()
    }

    fn analyze_template<W: LogWriter + ReportWriter>(&mut self, name: &str, writer: &mut W) {
        writer.write_message(&format!("analyzing template '{name}'"));

        // We take ownership of the CFG and any previously generated reports
        // here to avoid holding multiple mutable and immutable references to
        // `self`. This may lead to the CFG being regenerated during analysis if
        // the template is invoked recursively. If it is then ¯\_(ツ)_/¯.
        let mut reports = self.take_template_reports(name);
        if let Ok(cfg) = self.take_template(name) {
            for analysis_pass in get_analysis_passes() {
                reports.append(&mut analysis_pass(self, &cfg));
            }
            // Re-insert the CFG into the hash map.
            if self.replace_template(name, cfg) {
                debug!("template `{name}` CFG was regenerated during analysis");
            }
        }
        writer.write_reports(&reports, &self.file_library);
    }

    pub fn analyze_templates<W: LogWriter + ReportWriter>(
        &mut self,
        writer: &mut W,
        user_input_only: bool,
    ) {
        for name in self.template_names(user_input_only) {
            self.analyze_template(&name, writer);
        }
    }

    /// 从 main component 开始递归分析（模式 2）
    ///
    /// 这种模式会：
    /// 1. 检查是否存在 main component
    /// 2. 根据 main 的 public 列表调整信号的 private 属性
    /// 3. 从 main template 开始递归分析（通过 CFG 中的引用自动递归）
    pub fn analyze_from_main<W: LogWriter + ReportWriter>(&mut self, writer: &mut W) {
        let main_info = if let Some(ref info) = self.main_component {
            info.clone()
        } else {
            writer.write_message(
                "错误：没有找到 main component。请确保输入文件包含一个 main component声明。",
            );
            writer.write_message("如果你想分析库组件，请使用 --mode all 模式。");
            return;
        };

        writer.write_message(&format!(
            "从 main component '{}' 开始分析，公开输入：{:?}",
            main_info.template_name, main_info.public_inputs
        ));

        // 分析 main template
        let mut reports = self.take_template_reports(&main_info.template_name);
        if let Ok(cfg) = self.take_template(&main_info.template_name) {
            // 使用支持 public 列表的隐私污点分析
            reports.append(&mut crate::privacy_taint::find_privacy_taint_leaks_for_main(
                &cfg,
                &main_info.public_inputs,
                self.leak_threshold,
                self.min_leak_severity,
            ));

            // 运行其他分析过程（跳过隐私污点分析，因为已经手动运行了）
            for analysis_pass in get_analysis_passes().into_iter().skip(1) {
                reports.append(&mut analysis_pass(self, &cfg));
            }

            // 重新插入 CFG
            if self.replace_template(&main_info.template_name, cfg) {
                debug!(
                    "template `{}` CFG was regenerated during analysis",
                    main_info.template_name
                );
            }
        }
        writer.write_reports(&reports, &self.file_library);

        // 注：其他被 main 调用的 template 会通过 CFG 中的引用自动分析
        // 因为隠私污点分析会递归地访问子 CFG
    }

    fn analyze_function<W: LogWriter + ReportWriter>(&mut self, name: &str, writer: &mut W) {
        writer.write_message(&format!("analyzing function '{name}'"));

        // We take ownership of the CFG and any previously generated reports
        // here to avoid holding multiple mutable and immutable references to
        // `self`. This may lead to the CFG being regenerated during analysis if
        // the function is invoked recursively. If it is then ¯\_(ツ)_/¯.
        let mut reports = self.take_function_reports(name); // 获取与该函数相关的任何先前生成的报告
        if let Ok(cfg) = self.take_function(name) {
            // 获取cfg，如果获取到了，则执行大括号下的内容
            for analysis_pass in get_analysis_passes() {
                // 遍历所有已注册的【分析过程】（分析器），分析结果追加到reports中
                reports.append(&mut analysis_pass(self, &cfg));
            }
            // Re-insert the CFG into the hash map.
            if self.replace_function(name, cfg) {
                // 分析完成后，将分析结果（cfg）重新插入到哈希映射中，如果返回true，说明cfg在过程中被重复生成
                debug!("function `{name}` CFG was regenerated during analysis");
            }
        }
        writer.write_reports(&reports, &self.file_library);
    }

    pub fn analyze_functions<W: LogWriter + ReportWriter>(
        &mut self,
        writer: &mut W,
        user_input_only: bool,
    ) {
        for name in self.function_names(user_input_only) {
            self.analyze_function(&name, writer);
        }
    }

    /// Report cache from CFG generation. These will be emitted when the
    /// template is analyzed.
    fn append_template_reports(&mut self, name: &str, reports: &mut ReportCollection) {
        self.template_reports.entry(name.to_string()).or_default().append(reports);
    }

    /// Report cache from CFG generation. These will be emitted when the
    /// template is analyzed.
    fn take_template_reports(&mut self, name: &str) -> ReportCollection {
        self.template_reports.remove(name).unwrap_or_default()
    }

    /// Report cache from CFG generation. These will be emitted when the
    /// function is analyzed.
    fn append_function_reports(&mut self, name: &str, reports: &mut ReportCollection) {
        self.function_reports.entry(name.to_string()).or_default().append(reports);
    }

    /// Report cache from CFG generation. These will be emitted when the
    /// function is analyzed.
    fn take_function_reports(&mut self, name: &str) -> ReportCollection {
        self.function_reports.remove(name).unwrap_or_default()
    }

    fn cache_template(&mut self, name: &str) -> Result<&Cfg, AnalysisError> {
        if !self.template_cfgs.contains_key(name) {
            // The template CFG needs to be generated from the AST.
            if self.template_reports.contains_key(name) {
                // We have already failed to generate the CFG.
                return Err(AnalysisError::FailedToLiftTemplate { name: name.to_string() });
            }
            // Get the AST corresponding to the template.
            let Some(ast) = self.template_asts.get(name) else {
                trace!("failed to lift unknown template `{name}`");
                return Err(AnalysisError::UnknownTemplate { name: name.to_string() });
            };
            // Generate the template CFG from the AST. Cache any reports.
            let mut reports = ReportCollection::new();
            let cfg = generate_cfg(ast, &self.curve, &mut reports).map_err(|report| {
                reports.push(*report);
                trace!("failed to lift template `{name}`");
                AnalysisError::FailedToLiftTemplate { name: name.to_string() }
            })?;
            self.append_template_reports(name, &mut reports);
            self.template_cfgs.insert(name.to_string(), cfg);
            trace!("successfully lifted template `{name}`");
        }
        Ok(self.template_cfgs.get(name).unwrap())
    }

    fn cache_function(&mut self, name: &str) -> Result<&Cfg, AnalysisError> {
        if !self.function_cfgs.contains_key(name) {
            // The function CFG needs to be generated from the AST.
            if self.function_reports.contains_key(name) {
                // We have already failed to generate the CFG.
                return Err(AnalysisError::FailedToLiftFunction { name: name.to_string() });
            }
            // Get the AST corresponding to the function.
            let Some(ast) = self.function_asts.get(name) else {
                trace!("failed to lift unknown function `{name}`");
                return Err(AnalysisError::UnknownFunction { name: name.to_string() });
            };
            // Generate the function CFG from the AST. Cache any reports.
            let mut reports = ReportCollection::new();
            let cfg = generate_cfg(ast, &self.curve, &mut reports).map_err(|report| {
                reports.push(*report);
                trace!("failed to lift function `{name}`");
                AnalysisError::FailedToLiftFunction { name: name.to_string() }
            })?;
            self.append_function_reports(name, &mut reports);
            self.function_cfgs.insert(name.to_string(), cfg);
            trace!("successfully lifted function `{name}`");
        }
        Ok(self.function_cfgs.get(name).unwrap())
    }

    pub fn take_template(&mut self, name: &str) -> Result<Cfg, AnalysisError> {
        self.cache_template(name)?;
        // The CFG must be available since caching was successful.
        Ok(self.template_cfgs.remove(name).unwrap())
    }

    pub fn take_function(&mut self, name: &str) -> Result<Cfg, AnalysisError> {
        self.cache_function(name)?;
        // The CFG must be available since caching was successful.
        Ok(self.function_cfgs.remove(name).unwrap())
    }

    pub fn replace_template(&mut self, name: &str, cfg: Cfg) -> bool {
        self.template_cfgs.insert(name.to_string(), cfg).is_some()
    }

    pub fn replace_function(&mut self, name: &str, cfg: Cfg) -> bool {
        self.function_cfgs.insert(name.to_string(), cfg).is_some()
    }

    /// 批量生成所有模板和函数的 CFG
    pub fn generate_all_cfgs(&mut self) -> ReportCollection {
        let mut all_reports = ReportCollection::new();

        // 生成所有模板的 CFG
        let template_names: Vec<String> = self.template_asts.keys().cloned().collect();
        for name in template_names {
            if let Err(_) = self.cache_template(&name) {
                debug!("Failed to generate CFG for template '{}'", name);
            }
        }

        // 生成所有函数的 CFG
        let function_names: Vec<String> = self.function_asts.keys().cloned().collect();
        for name in function_names {
            if let Err(_) = self.cache_function(&name) {
                debug!("Failed to generate CFG for function '{}'", name);
            }
        }

        // 收集所有生成过程中的报告
        for (_, reports) in &self.template_reports {
            all_reports.append(&mut reports.clone());
        }
        for (_, reports) in &self.function_reports {
            all_reports.append(&mut reports.clone());
        }

        all_reports
    }

    /// 使用 CfgManager 统一连接所有 CFG 引用
    ///
    /// 注意：此方法会将 runner 中的 CFG 移动到返回的 CfgManager 中。
    /// 这是因为 Cfg 不支持 Clone，无法同时在两个地方保存。
    /// 如需要继续使用 runner 的原始功能，在调用此方法前完成相关操作。
    pub fn link_all_cfg_references(&mut self) -> crate::cfg_manager::CfgManager {
        use crate::cfg_manager::CfgManager;

        let mut cfg_manager = CfgManager::new();

        // 将所有模板 CFG 移动到管理器
        let template_cfgs = std::mem::take(&mut self.template_cfgs);
        for (name, cfg) in template_cfgs {
            cfg_manager.add_template_cfg(name, cfg);
        }

        // 将所有函数 CFG 移动到管理器
        let function_cfgs = std::mem::take(&mut self.function_cfgs);
        for (name, cfg) in function_cfgs {
            cfg_manager.add_function_cfg(name, cfg);
        }

        // 统一链接所有调用引用
        cfg_manager.link_call_references();

        cfg_manager
    }
}

impl AnalysisContext for AnalysisRunner {
    fn is_template(&self, name: &str) -> bool {
        self.template_asts.contains_key(name)
    }

    fn is_function(&self, name: &str) -> bool {
        self.function_asts.contains_key(name)
    }

    fn template(&mut self, name: &str) -> Result<&Cfg, AnalysisError> {
        self.cache_template(name)
    }

    fn function(&mut self, name: &str) -> Result<&Cfg, AnalysisError> {
        self.cache_function(name)
    }

    fn underlying_str(
        &self,
        file_id: &FileID,
        file_location: &FileLocation,
    ) -> Result<String, AnalysisError> {
        let Ok(file) = self.file_library.to_storage().get(*file_id) else {
            return Err(AnalysisError::UnknownFile { file_id: *file_id });
        };
        if file_location.end <= file.source().len() {
            Ok(file.source()[file_location.start..file_location.end].to_string())
        } else {
            Err(AnalysisError::InvalidLocation {
                file_id: *file_id,
                file_location: file_location.clone(),
            })
        }
    }

    fn leak_threshold(&self) -> usize {
        self.leak_threshold
    }

    fn min_leak_severity(&self) -> LeakSeverity {
        self.min_leak_severity
    }
}

fn generate_cfg<Ast: IntoCfg>(
    ast: Ast,
    curve: &Curve,
    reports: &mut ReportCollection,
) -> Result<Cfg, Box<Report>> {
    ast.into_cfg(curve, reports)
        .map_err(|error| Box::new(error.into()))?
        .into_ssa()
        .map_err(|error| Box::new(error.into()))
}

#[cfg(test)]
mod tests {
    use program_structure::ir::Statement;
    use program_structure::writers::CachedStdoutWriter;
    use super::*;

    #[test]
    fn test_function() {
        // let mut runner = AnalysisRunner::new(Curve::Goldilocks).with_src(&[r#"
        //     function foo(a) {
        //         return a[0] + a[1];
        //     }
        // "#]);

        let mut runner = AnalysisRunner::new(Curve::Goldilocks).with_src(&[r#"
            function foo(a, b) {
                var result;
                if (a > b) {
                    result = a;
                } else {
                    result = b;
                }
                return result;
            }
        "#]);

        // Check that `foo` is a known function, that we can access the CFG
        // for `foo`, and that the CFG is properly cached.
        assert!(runner.is_function("foo"));
        assert!(!runner.function_cfgs.contains_key("foo"));
        assert!(runner.function("foo").is_ok());
        assert!(runner.function_cfgs.contains_key("foo"));

        // Check that the `take_function` and `replace_function` APIs work as expected.
        let cfg = runner.take_function("foo").unwrap();
        assert!(!runner.function_cfgs.contains_key("foo"));
        assert!(!runner.replace_function("foo", cfg));
        assert!(runner.function_cfgs.contains_key("foo"));

        // Check that `baz` is not a known function, that attempting to access
        // `baz` produces an error, and that nothing is cached.
        assert!(!runner.is_function("baz"));
        assert!(!runner.function_cfgs.contains_key("baz"));
        assert!(matches!(runner.function("baz"), Err(AnalysisError::UnknownFunction { .. })));
        assert!(!runner.function_cfgs.contains_key("baz"));
    }

    #[test]
    fn test_template() {
        let mut runner = AnalysisRunner::new(Curve::Goldilocks).with_src(&[r#"
            template Foo(n) {
                signal input a[2];

                a[0] === a[1];
            }
        "#]);

        // Check that `Foo` is a known template, that we can access the CFG
        // for `Foo`, and that the CFG is properly cached.
        assert!(runner.is_template("Foo"));
        assert!(!runner.template_cfgs.contains_key("Foo"));
        assert!(runner.template("Foo").is_ok());
        assert!(runner.template_cfgs.contains_key("Foo"));

        // Check that the `take_template` and `replace_template` APIs work as expected.
        let cfg = runner.take_template("Foo").unwrap();
        assert!(!runner.template_cfgs.contains_key("Foo"));
        assert!(!runner.replace_template("Foo", cfg));
        assert!(runner.template_cfgs.contains_key("Foo"));

        // Check that `Baz` is not a known template, that attempting to access
        // `Baz` produces an error, and that nothing is cached.
        assert!(!runner.is_template("Baz"));
        assert!(!runner.template_cfgs.contains_key("Baz"));
        assert!(matches!(runner.template("Baz"), Err(AnalysisError::UnknownTemplate { .. })));
        assert!(!runner.template_cfgs.contains_key("Baz"));
    }

    #[test]
    fn test_underlying_str() {
        use Statement::*;
        let mut runner = AnalysisRunner::new(Curve::Goldilocks).with_src(&[r#"
            template Foo(n) {
                signal input a[2];

                a[0] === a[1];
            }
        "#]);

        let cfg = runner.take_template("Foo").unwrap();
        for stmt in cfg.entry_block().iter() {
            let file_id = stmt.meta().file_id().unwrap();
            let file_location = stmt.meta().file_location();
            let string = runner.underlying_str(&file_id, &file_location).unwrap();
            match stmt {
                // TODO: Why do some statements include the semi-colon and others don't?
                Declaration { .. } => assert_eq!(string, "signal input a[2]"),
                ConstraintEquality { .. } => assert_eq!(string, "a[0] === a[1];"),
                _ => unreachable!(),
            }
        }
    }

    #[test]
    fn test_with_files() {
        use std::path::Path;

        // 使用项目目录下的测试文件
        let project_root = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();
        let test_file = project_root.join("examples").join("instantiation.circom");
        let test_file = project_root.join("examples").join("instantiation.circom");

        // let test_file = project_root.join("test_fixtures").join("template.circom");

        // 确保测试文件存在
        assert!(test_file.exists(), "Test file should exist: {:?}", test_file);

        let (mut runner, reports) = AnalysisRunner::new(Curve::Bn254).with_files(&[test_file]);

        // 验证解析成功
        //assert!(reports.is_empty() || reports.iter().all(|r| !r.is_error()));
        //assert!(runner.is_template("TestTemplate"));
        //assert!(runner.is_template("MultiplyAdd"));

        // Set up writer and write reports to `stdout`.
        let mut stdout_writer = CachedStdoutWriter::new(false);
        stdout_writer.write_reports(&reports, runner.file_library());

        // Analyze functions and templates in user provided input files.
        // 分析入口
        runner.analyze_functions(&mut stdout_writer, true);
        runner.analyze_templates(&mut stdout_writer, true);
    }

    #[test]
    fn test_with_directory() {
        use std::fs;
        use std::path::Path;

        // 使用项目目录下的测试文件夹
        let project_root = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();
        let test_dir = project_root.join("examples2");

        // 确保测试目录存在
        assert!(test_dir.exists(), "Test directory should exist: {:?}", test_dir);

        // 收集目录中的所有.circom文件
        let circom_files: Vec<PathBuf> = fs::read_dir(&test_dir)
            .unwrap()
            .filter_map(|entry| {
                let entry = entry.ok()?;
                let path = entry.path();
                if path.extension()? == "circom" {
                    Some(path)
                } else {
                    None
                }
            })
            .collect();

        assert!(!circom_files.is_empty(), "Should find at least one .circom file");

        let (mut runner, reports) =
            AnalysisRunner::new(Curve::Goldilocks).with_files(&circom_files);

        // 验证解析成功
        // assert!(reports.is_empty() || reports.iter().all(|r| !r.is_error()));

        // 验证从不同文件解析出的模板和函数
        // assert!(runner.is_template("MultiplyAdd"));
        // assert!(runner.is_template("TestTemplate"));
        // assert!(runner.is_template("BitwiseOps"));
        // assert!(runner.is_template("Comparator"));
        // assert!(runner.is_function("max"));
        // assert!(runner.is_function("min"));
        // assert!(runner.is_function("factorial"));
        // assert!(runner.is_function("power"));

        // 测试分析功能
        let template_names = runner.template_names(true);
        let function_names = runner.function_names(true);

        println!("Found templates: {:?}", template_names);
        println!("Found functions: {:?}", function_names);
    }

    #[test]
    fn test_cfg_reference_linking() {
        use std::fs;
        use std::path::Path;
        use program_structure::ir::{Expression, Statement};

        // 辅助函数：在语句中递归查找指定名称的调用表达式
        fn find_call_expression_in_statement<'a>(
            stmt: &'a Statement,
            target_name: &str,
        ) -> Option<&'a Expression> {
            use Statement::*;
            match stmt {
                Substitution { rhe, .. } => find_call_expression_in_expr(rhe, target_name),
                ConstraintEquality { lhe, rhe, .. } => {
                    find_call_expression_in_expr(lhe, target_name)
                        .or_else(|| find_call_expression_in_expr(rhe, target_name))
                }
                Return { value, .. } => find_call_expression_in_expr(value, target_name),
                IfThenElse { cond, .. } => find_call_expression_in_expr(cond, target_name),
                Assert { arg, .. } => find_call_expression_in_expr(arg, target_name),
                Declaration { dimensions, .. } => {
                    for dim in dimensions {
                        if let Some(expr) = find_call_expression_in_expr(dim, target_name) {
                            return Some(expr);
                        }
                    }
                    None
                }
                LogCall { .. } => None, // 简化处理
            }
        }

        // 辅助函数：在表达式中递归查找指定名称的调用表达式
        fn find_call_expression_in_expr<'a>(
            expr: &'a Expression,
            target_name: &str,
        ) -> Option<&'a Expression> {
            use Expression::*;
            match expr {
                Call { name, .. } if name == target_name => Some(expr),
                Call { args, .. } => {
                    for arg in args {
                        if let Some(found) = find_call_expression_in_expr(arg, target_name) {
                            return Some(found);
                        }
                    }
                    None
                }
                InfixOp { lhe, rhe, .. } => find_call_expression_in_expr(lhe, target_name)
                    .or_else(|| find_call_expression_in_expr(rhe, target_name)),
                PrefixOp { rhe, .. } => find_call_expression_in_expr(rhe, target_name),
                SwitchOp { cond, if_true, if_false, .. } => {
                    find_call_expression_in_expr(cond, target_name)
                        .or_else(|| find_call_expression_in_expr(if_true, target_name))
                        .or_else(|| find_call_expression_in_expr(if_false, target_name))
                }
                InlineArray { values, .. } => {
                    for value in values {
                        if let Some(found) = find_call_expression_in_expr(value, target_name) {
                            return Some(found);
                        }
                    }
                    None
                }
                Update { rhe, .. } => find_call_expression_in_expr(rhe, target_name),
                _ => None,
            }
        }

        // 使用项目目录下的 examples2 测试文件夹
        let project_root = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();
        let test_dir = project_root.join("examples2");

        // 确保测试目录存在
        assert!(test_dir.exists(), "Test directory should exist: {:?}", test_dir);

        // 收集目录中的所有.circom文件
        let circom_files: Vec<PathBuf> = fs::read_dir(&test_dir)
            .unwrap()
            .filter_map(|entry| {
                let entry = entry.ok()?;
                let path = entry.path();
                if path.extension()? == "circom" {
                    Some(path)
                } else {
                    None
                }
            })
            .collect();

        assert!(!circom_files.is_empty(), "Should find at least one .circom file");

        let (mut runner, _reports) =
            AnalysisRunner::new(Curve::Goldilocks).with_files(&circom_files);

        // 第一阶段：批量生成所有 CFG
        println!("Phase 1: Generating all CFGs...");
        let generation_reports = runner.generate_all_cfgs();
        println!("CFG generation completed with {} reports", generation_reports.len());

        // 验证 CFG 已生成
        assert!(runner.is_template("Foo"), "Template 'Foo' should be available");
        assert!(runner.is_function("isNegative"), "Function 'isNegative' should be available");

        // 第二阶段：统一连接所有 CFG 引用
        println!("Phase 2: Linking all CFG references...");
        let cfg_manager = runner.link_all_cfg_references();

        // 验证 CFG 管理器包含预期的模板和函数
        assert!(cfg_manager.has_template("Foo"), "CfgManager should contain template 'Foo'");
        assert!(
            cfg_manager.has_function("isNegative"),
            "CfgManager should contain function 'isNegative'"
        );

        // 第三阶段：验证调用引用已正确链接
        println!("Phase 3: Verifying call reference linking...");

        // 获取 Foo 模板的 CFG 来检查调用链接
        if let Some(foo_cfg_ref) = cfg_manager.get_template_cfg_ref("Foo") {
            let foo_cfg = foo_cfg_ref.borrow();
            let mut found_linked_call = false;

            // 遍历 CFG 中的所有语句，查找对 isNegative 函数的调用
            for block in foo_cfg.iter() {
                for stmt in block.iter() {
                    if let Some(call_expr) = find_call_expression_in_statement(stmt, "isNegative") {
                        if let Expression::Call { target_cfg: Some(weak_ref), .. } = call_expr {
                            // 验证弱引用可以成功升级为强引用
                            if let Some(target_cfg) = weak_ref.upgrade() {
                                let target = target_cfg.borrow();
                                println!(
                                    "Successfully found linked call to '{}' in template 'Foo'",
                                    target.name()
                                );
                                found_linked_call = true;
                            }
                        }
                    }
                }
            }

            assert!(
                found_linked_call,
                "Should find at least one linked call to 'isNegative' function"
            );
        } else {
            panic!("Failed to get CFG reference for template 'Foo'");
        }

        println!("CFG reference linking test completed successfully!");
    }
}
